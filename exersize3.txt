    /**
     * Given a data in String format, find its LaboonHash value.
     * Note LaboonHash is generally not a hashing algorithm you would
     * want to use in real life.
     * The LaboonHash algorithm is as follows:
     *   1. Convert a String into a sequence of characters
     *   2. Initialize a starting value, n, of 10000000 (10 million)
     *   3. For each character, multiply n by its ASCII (char) value 
     *   4. After multiplication, add the value of the ASCII (char) value to n
     *   5. Return n
     * For example, the LaboonHash of "boo" is:
     *   n = 10000000
     *   n = (n * 98) + 98 // 98 = ASCII of 'b'
     *   n = (n * 111) + 111 // 111 = ASCII of 'o'
     *   n = (n * 111) + 111 // 111 = ASCII of 'o'
     *   Final hash: 12074581219890
     * Or:
     *   n = 1000000
     *   n = (1000000 * 98) + 98 = 980000098
     *   n = (980000098 * 111) + 111 = 108780010989
     *   n = (108780010989 * 111) + 11 = 12074581219890
     *   n = 12074581219890
     * However, this is held in a 32-bit signed int and so will wrap around!
     * Thus it will be 1428150834, or 0x551fda32.
     * Some other helpful examples for testing are below.
     * "bill" (no quotes) hashes to 0x53c4142c
     * "laboon" (no quotes) hashes to 0x4e4587d6
     * null or the empty string hash to 0x00989680
     * @param data - entire piece of data to hash
     * @return int - hash value using LaboonHash algorithm
     */
    
    public int hash(String data) {
	// TODO - IMPLEMENT LABOONHASH
	
	char[] char_arr= data.toCharArray[];
	char_arr = data;
	int n = 10000000

	for each num in char_arr:
		int ascii_val = (int) num;
		n = n + (n * ascii_val);

	return n;
	
    }



    /**
     * Given a certain level of difficulty, check to see if a given hash
     * has that many 0's at its beginning, when expressed as a hex String.
     * For example, assume difficulty level is set to 3.
     * 0x098ab873 is NOT valid - it only has one 0 at the beginning
     * 0xab000000 is NOT valid - despite having six 0's, they are not at the 
     *                           beginning
     * 0x000fd98a IS valid     - it has three 0's at the beginning
     * 0x000000d4 IS valid     - it has three 0's at the beginning, plus more
     * 
     * @param difficulty - Difficulty level (number of 0's)
     * @param hash - hash value to check
     * @return boolean - true if hash is valid for a block, false otherwise
     */
    
    public boolean validHash(int difficulty, int hash) {
	// TODO - CHECK FOR VALID HASHES
	
	int count = 0
	
	String str_hash = hash.toString()
	char[] char_arr= str_hash.toCharArray[];
	
	for int i = 0; i <= difficulty; i++{
		if (char[i] == '0') count++;
	}
	if (count >= difficulty) return true;

	return false;
    }	


// Tests for hash function
@Test
public void testHashValid(){
	String() str = "laboon";
	result = hash(str)
	assertEquals(0x4e4587d6, result)
}

@Test
public void testHashValid(){
	String() str;
	result = hash(str)
	assertEquals(0x00989680, result)
}

@Test
public void testHashInvalid_intInput(){
	result = hash(298397478)
	assertFails ?
}


//Tests for validHash function
// given bad hash, given bad difficulty, given good everything

@Test
public void testValidHashInvalid_intHashInput(){

}

@Test
public void test testValidHashValid_zeroDifficulty(){

}

@Test
public void test testValidHashValid(){

}
